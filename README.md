 ##数据库基本问题
 ###一、acid是什么 原子性，一致性，隔离性，持久性
 * 只有满足一致性，事务的执行结果才是正确的。
 * 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
 * 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
 * 事务满足持久化是为了能应对系统崩溃的情况。
 ![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207210437023.png)
 
 ###二、并发一致性问题
 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。
####丢失修改（两次同时改，重置）
T1和T2两个事务都对一个数据进行修改T1先修改，T2后修改，只保留了T2修改的结果，T1的结果被重置了
![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png)
####读脏数据 (先改再读再撤销)
T1修改一个数据，T2读取这个数据，此时T1撤销操作，T2读的就是脏数据
![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png)
####不可重复读（update造成两次数据不一致）
T2读取某个数据，T1对这个数据进行修改，T2再次读取这个数据，两次读取数据不一致，
![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png)
####幻影读（inset造成两次数据不一致）
T1读取某个范围的数据，T2在这个范围中插入新的数据，T1再次读取，发现数据不一致。
 
 ###三、锁
 锁的粒度
 行级锁和表级锁，锁的粒度越小，并发越高，但是系统开销越大。
 锁的类型 
 读写锁 互斥（x）和共享（s）
 规定，一个事物对数据对象加了一个x锁，可以对该数据对象查询和修改。而其它事务不能加任何锁
 规定，一个事物对数据对象加了一个s锁，只能对该数据对象查询。而其它事务只能加s锁
 ![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207213523777.png)
 2.意向锁
 使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。
 
四、隔离级别
未提交读
事物中的修改即使没有提及，对其它事物来说，也是可读的
提交读（和上面相反）
可重复读
保证在同一事务中多次读取同一数据的结果是一致的
可串行化
强制事务串行执行多个事务互不干扰，需要加锁实现。
![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png)


 
 
 


 